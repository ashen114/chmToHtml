<!DOCTYPE html>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, minimumscale=1.0, maximum-scale=1.0" />
<meta name="language" content="zh-cn" />
<meta name="renderer" content="webkit" />
<title>Node.js Net 模块</title>
<link rel="stylesheet" type="text/css" href="../style/prettify.css" />
<link rel="stylesheet" type="text/css" href="../style/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" href="../style/love.css" />
<script type="text/javascript" src="../style/jquery.min.js"></script>
<script type="text/javascript" src="../style/bootstrap.min.js"></script>
<script type="text/javascript" src="../style/prettify.js"></script>
</head>
<body>
<div class="m-bg">
	<h1>Node.js Net 模块</h1>
	<hr>
		 <p></p> <p> Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块： </p> <pre>
var net = require("net")
</pre> <h3>方法</h3> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>net.createServer([options][, connectionListener])</b><br>创建一个 TCP 服务器。参数 connectionListener 自动给 'connection' 事件创建监听器。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>net.connect(options[, connectionListener])</b><br>返回一个新的 'net.Socket'，并连接到指定的地址和端口。<br> 当 socket 建立的时候，将会触发 'connect' 事件。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>net.createConnection(options[, connectionListener])</b><br>创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 'localhost'。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>net.connect(port[, host][, connectListener])</b><br>创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 'localhost'。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。</td>
</tr>
<tr>
<td>5</td>
<td>
<b>net.createConnection(port[, host][, connectListener])</b><br>创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 'localhost'。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。</td>
</tr>
<tr>
<td>6</td>
<td>
<b>net.connect(path[, connectListener])</b><br>创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect' 事件上。返回 'net.Socket'。</td>
</tr>
<tr>
<td>7</td>
<td>
<b>net.createConnection(path[, connectListener])</b><br>创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。</td>
</tr>
<tr>
<td>8</td>
<td>
<b>net.isIP(input)</b><br>检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。</td>
</tr>
<tr>
<td>9</td>
<td>
<b>net.isIPv4(input)</b><br>如果输入的地址为 IPV4， 返回 true，否则返回 false。</td>
</tr>
<tr>
<td>10</td>
<td>
<b>net.isIPv6(input)</b><br>如果输入的地址为 IPV6， 返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<hr>
<h2>net.Server</h2> <p>net.Server通常用于创建一个 TCP 或本地服务器。</p> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>server.listen(port[, host][, backlog][, callback])</b><br>监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>server.listen(path[, callback])</b><br>通过指定 path 的连接，启动一个本地 socket 服务器。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>server.listen(handle[, callback])</b><br>通过指定句柄连接。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>server.listen(options[, callback])</b><br>options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。</td>
</tr>
<tr>
<td>5</td>
<td>
<b>server.close([callback])</b><br>服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 'close' 事件。</td>
</tr>
<tr>
<td>6</td>
<td>
<b>server.address()</b><br>操作系统返回绑定的地址，协议族名和服务器端口。</td>
</tr>
<tr>
<td>7</td>
<td>
<b>server.unref()</b><br>如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。</td>
</tr>
<tr>
<td>8</td>
<td>
<b>server.ref()</b><br>与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</td>
</tr>
<tr>
<td>9</td>
<td>
<b>server.getConnections(callback)</b><br>异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</td>
</tr>
</tbody></table>
<h3>事件</h3> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>事件 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>listening</b><br>当服务器调用 server.listen 绑定后会触发。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>connection</b><br>当新连接创建后会被触发。socket 是 net.Socket实例。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>close</b><br>服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>error</b><br>发生错误时触发。'close' 事件将被下列事件直接调用。</td>
</tr>
</tbody></table>
<hr>
<h2>net.Socket</h2> <p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。</p> <h3>事件</h3> <p>net.Socket 事件有：</p> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>事件 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>lookup</b><br> 在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>connect</b><br>成功建立 socket 连接时触发。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>data</b><br>当接收到数据时触发。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>end</b><br>当 socket 另一端发送 FIN 包时，触发该事件。</td>
</tr>
<tr>
<td>5</td>
<td>
<b>timeout</b><br>当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。</td>
</tr>
<tr>
<td>6</td>
<td>
<b>drain</b><br>当写缓存为空得时候触发。可用来控制上传。</td>
</tr>
<tr>
<td>7</td>
<td>
<b>error</b><br>错误发生时触发。</td>
</tr>
<tr>
<td>8</td>
<td>
<b>close</b><br>当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。</td>
</tr>
</tbody></table>
<h3>属性</h3> <p>net.Socket 提供了很多有用的属性，便于控制 socket 交互：</p> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>属性 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>socket.bufferSize</b><br>该属性显示了要写入缓冲区的字节数。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>socket.remoteAddress</b><br>远程的 IP 地址字符串，例如：'74.125.127.100' or '2001:4860:a005::68'。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>socket.remoteFamily</b><br>远程IP协议族字符串，比如 'IPv4' or 'IPv6'。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>socket.remotePort</b><br>远程端口，数字表示，例如：80 or 21。</td>
</tr>
<tr>
<td>5</td>
<td>
<b>socket.localAddress</b><br>网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听'0.0.0.0'而客户端连接在'192.168.1.1'，这个值就会是 '192.168.1.1'。</td>
</tr>
<tr>
<td>6</td>
<td>
<b>socket.localPort</b><br>本地端口地址，数字表示。例如：80 or 21。</td>
</tr>
<tr>
<td>7</td>
<td>
<b>socket.bytesRead</b><br>接收到得字节数。</td>
</tr>
<tr>
<td>8</td>
<td>
<b>socket.bytesWritten</b><br>发送的字节数。</td>
</tr>
</tbody></table>
<h3>方法</h3> <table class="reference"><tbody>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
<tr>
<td>1</td>
<td>
<b>new net.Socket([options])</b><br>构造一个新的 socket 对象。</td>
</tr>
<tr>
<td>2</td>
<td>
<b>socket.connect(port[, host][, connectListener])</b><br> 指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</td>
</tr>
<tr>
<td>3</td>
<td>
<b>socket.connect(path[, connectListener])</b><br>打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</td>
</tr>
<tr>
<td>4</td>
<td>
<b>socket.setEncoding([encoding])</b><br>设置编码</td>
</tr>
<tr>
<td>5</td>
<td>
<b>socket.write(data[, encoding][, callback])</b><br>在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。</td>
</tr>
<tr>
<td>6</td>
<td>
<b>socket.end([data][, encoding])</b><br>半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。</td>
</tr>
<tr>
<td>7</td>
<td>
<b>socket.destroy()</b><br>确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。</td>
</tr>
<tr>
<td>8</td>
<td>
<b>socket.pause()</b><br>暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。</td>
</tr>
<tr>
<td>9</td>
<td>
<b>socket.resume()</b><br>调用 pause() 后想恢复读取数据。</td>
</tr>
<tr>
<td>10</td>
<td>
<b>socket.setTimeout(timeout[, callback])</b><br>socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。</td>
</tr>
<tr>
<td>11</td>
<td>
<b>socket.setNoDelay([noDelay])</b><br>禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。</td>
</tr>
<tr>
<td>12</td>
<td>
<b>socket.setKeepAlive([enable][, initialDelay])</b><br>禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.</td>
</tr>
<tr>
<td>13</td>
<td>
<b>socket.address()</b><br>操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: 'IPv4', address: '127.0.0.1' }。</td>
</tr>
<tr>
<td>14</td>
<td>
<b>socket.unref()</b><br>如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。 </td>
</tr>
<tr>
<td>15</td>
<td>
<b>socket.ref()</b><br>与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</td>
</tr>
</tbody></table>
<h3>实例</h3> <p>创建 server.js 文件，代码如下所示：</p> <pre>
var net = require('net');
var server = net.createServer(function(connection) { 
   console.log('client connected');
   connection.on('end', function() {
      console.log('客户端关闭连接');
   });
   connection.write('Hello World!\r\n');
   connection.pipe(connection);
});
server.listen(8080, function() { 
  console.log('server is listening');
});
</pre> <p>执行以上服务端代码：</p> <pre>
$ node server.js
server is listening   # 服务已创建并监听 8080 端口
</pre> <p>新开一个窗口，创建 client.js 文件，代码如下所示：</p> <pre>
var net = require('net');
var client = net.connect({port: 8080}, function() {
   console.log('连接到服务器！');  
});
client.on('data', function(data) {
   console.log(data.toString());
   client.end();
});
client.on('end', function() { 
   console.log('断开与服务器的连接');
});
</pre> <p>执行以上客户端的代码：</p> <pre>
连接到服务器！
Hello World!

断开与服务器的连接
</pre> <h3>Gif 实例演示</h3> <img src="../image/56134de7df29f.gif"><p></p> 	<div class="text-center padding-10 margin-t-5">
					</div>
</div>
<div class="m-bg text-center margin-t-10">
	<p>
		<a class="btn btn-xs btn-default" href="http://www.shouce.ren/main/about">关于我们</a>
		<a class="btn btn-xs btn-default" href="http://www.shouce.ren/main/contact">联系我们</a>
		<a class="btn btn-xs btn-default" href="http://www.shouce.ren/main/lyb">留言板</a>
	</p>
	<p><a class="btn btn-xs btn-default" href="http://www.shouce.ren">手册网</a></p>
</div>
<script type="text/javascript">
$(function(){
	$("pre").addClass("prettyprint linenums");
	//代码高亮
	prettyPrint();
	$("table").attr('class','table table-striped table-bordered table-condensed');
});
</script>
</body>
</html>
